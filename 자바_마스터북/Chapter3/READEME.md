## 자바는 정적 타입 언어
- 변수의 선언 시에 타입을 명기
- 선언 시에는 타입을 명확하게 하지 않고 실행 시에 타입의 정합성을 체크: 동적 타입 언어
    - JavaScript, Ruby

## 기본형
- 논리형, 숫자형, 문자열형
- 소스 코드에 직접 기술된 값을 리터럴이라고 부름
- 긴 숫자형의 경우 언더스코어로 구분 표기 가능(자바8 이상)
    - `long amount = 123_456_789L;`
- 확장 변환 가능
    - short -> int
- 축소 변환 불가능
    - int -> short
    - 강제로 캐스팅해야한다
    - 큰 그릇의 물을 작은 그릇의 물에 담으면 물이 흘러넘칠 수 있는 것처럼 데이터가 유실될 수 있다

## 참조형
- 인스턴스를 특정하는 정보
- String 클래스


## 래퍼 클래스
- Byte, Short, Integer, Long, Character, Float, Double, Boolean, SIZE, BYTES, MAX_VALUE, MIN_VALUE
- valueOf(기본형의 값)
    - 기본형으로부터 래퍼 클래스의 객체로 변환
- valueOf(String s)
    - 문자열로부터 래퍼 클래스의 객체로 변환
- valueOf(String s, int radix)
    - 진수를 지정해서 문자열로부터 래퍼 클래스의 객체로 변환
- parseXxx(String s)
    - 문자열로부터 기본형의 값으로 변환
- toString(기본형의 값)
    - 기본형에서 문자열로 변환
- 래퍼 클래스는 초깃값이 null
- new Integer(10)와 같이 사용하는 것보다는, Integer.valueOf(10)을 사용하자!
    - -127~128 범위라면 사전에 생성된 객체를 이용할 수 있으므로 메모리 효율적
- 래퍼와 기본형이 크게 다른점은 초깃값
    - Integer: null
    - int: 0
    - 0과 데이터가 없는 상태를 구별하고 싶은 경우는 래퍼형을 준비 (HTTP 통신 등)
    - 수치 계산에 이용하는 변수는 기본형. 래퍼 -> 기본형 변환에 걸리는 시간도 무시할 수 없으므로

## 오토박싱과 언박싱
```java
int num = 10;
Integer numInt = 10; // 컴파일시 Integer.valueOf(10)으로 자동 변환, 오토박싱
Integer sum =- num + numInt; // numInt가 numInt.intValue()의 int로 자동 변환되어 언박싱, 연산결과를 다시 오토박싱한다
```

```java
Integer num1 = new Integer(3);
Integer num2 = new Integer(3);

num1 == num2; // false (객체가 다름)
num1.equals(num2); // true

Integer int1 = 128;
Integer int2 = 128;
int1 == int2; // false

Integer int1 = 127;
Integer int2 = 127;
int1 == int2; // true, -128 ~ 127의 범위 값에는 사전에 생성된 객체가 이용됨, 해당 값을 오토박싱한 객체는 항상 동일 객체가 됨
```

## 요약
* 원칙적으로 오토박싱, 언박싱은 이용하지 않고 명시적인 변환을 실시
* 파일이나 데이터베이스, HTTP 요청 등을 유지하는 값은 래퍼 클래스를 사용한다
* 수치 연산에 사용하는 변수는 기본형으로 한다
* 코딩량의 감소에 효과적인 경우에 한하여 오토박싱, 언박싱을 이용한다



### 접근 제한자

- public
  - 다른 모든 클래스로부터 참조 가능
- protected
  - 자식 클래스 및 동일 패키지 내의 클래스로부터 참조 가능
- (지정없음)
  - 동일 패키지 내의 클래스로부터 참조 가능 (package private)
- private
  - 자기 자신의 클래스 안에서만 액세스 가능 (자식 클래스로부터 참조 불가능)

`새로운 패키지의 클래스가 패키지 프라이빗인 경우 그 클래스가 갖는 메서드가 public이라고 해도 원래부터 부모 클래스를 import 할 수 없어 호출 X`



### 그 외 자주 이용하는 수식자

- static 수식자
  - 클래스 멤버
  - 클래스에 연관되어 있기 때문에 2개의 서로 다른 인스턴스로부터 참조한 경우 동일한 값을 얻을 수 있다.
  - 각각 다른 인스턴스에서 한쪽의 인스턴스 클래스 필드에서 값을 변경시, 다른쪽의 인스턴스 클래스 필드도 동일하게 변경된다
- final 수식자
  - 변수를 변경할 수 없도록함
  - static + final => 상수 or 클래스 상수
  - 대문자의 스네이크 케이스로 기술



### 계승

- 오버라이드하고 있지 않은 메서드를 호출할 때는 일반적으로 super 생략
- 오버라이드하고 있는 메서드의 부모 메서드를 호출하고 싶을 경우 super를 붙임



### 추상 클래스

- 추상 메서드를 하나라도 갖는 클래스
- 상위 클래스에서 추상메소드 구현, 하위 클래스에서 각각의 입맛에 맞게끔 구현



### 인터페이스

- 확장성을 높이기 위함
- 목적에 따라 객체 교환 가능
- 인터페이스는 반드시 public 이므로 생략 가능
- 인터페이스내에서 상수(public static final) 정의 가능
  - 생략 가능



### 익명 클래스

- 이름이 없는 클래스
- 무명의 어떠한 클래스가 부모 클래스로부터 상속을 받은 인스턴스
- 이름이 없으므로 생성자를 선언할 수 X
- 메서드 자체는 못 넘기되 메서드를 감싼 익명 클래스를 넘길 수 있다 



### 객체의 등가성

- 동일 객체 -> == 연산자
- 객체의 값 비교 -> .eqauls
- hashCode 메서드
  - 동일 객체의 해시값은 반드시 동일
  - 해시값이 다른 경우에는 서로 다른 객체
  - 서로 다른 객체라도 해시값이 동일한 경우가 존재
- 객체가 동일한지 판별하는 법
  - 객체의 hashCode 메서드의 값이 동일한가
  - equals 메서드로 같다고 판정되었는가
- IDE의 기능을 이용하여 hashCode 메서드와 equals 메서드를 자동 생성



### 열거형

- 상수 대신 enum 사용

```java
public static final String SELECTED_COLOR = "blue" // 상수 클래스 정의
public String color = SELECTED_COLOR; // 이용 클래스 정의
/*
컴파일
*/
public String color = "blue"; // 이용 클래스는 이렇게 SELECTED_COLOR를 할당받는게 아니라 blue 값을 할당 받는다. 즉, SELECTED_COLOR가 바뀌었는지 이용 클래스에서는 알 수 가 없으므로, 바뀐다면 이용 클래스쪽에서 컴파일을 다시 해서 바뀐 값을 할당 받아야한다.
```



### 제네릭스

* 객체의 타입 안정성 보장
* 